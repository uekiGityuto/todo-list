# pencil.devのKnowledge

## 前提

- 要件定義が完了していること
- 技術スタックが決まっていること（フレームワーク、UIライブラリ）

## コツ

- ある程度制約を設けて好き勝手させない
- 作って壊して（変更して）を繰り返すので、壊しやすいように（変更しやすいように）しておく
- ファイルを跨いでコンポーネントを利用できない（？）ので、1ファイルで完結させる必要がある
- Claude Codeがデザインファイル全体を見て配置しないので、既に描いた画面の上に重ねて新しい画面を描いてしまったりする。事前に配置ルールを決めると良い。
  - 上から下に向かって、コンポーネント（スタイルガイドも含む）、モバイルデザイン、PCデザインの順で配置する
  - コンポーネント、モバイルデザイン、PCデザインは結構距離を離して配置する。そうしないと、コンポーネントや画面を増やすたびに重なってしまう
  - コンポーネントについて、
    - 白背景か黒背景のカードの上に置くと見やすい（デフォルトがライトモードがであれば白背景、ダークモードであれば黒背景のカード）
  - モバイルデザインとPCデザインについて、
    - 画面ごとに列を決める。その画面の別パターンや、その画面から開くダイアログやボトムシートはその下に描いていく
    - 新しい画面を追加するときは、既存の画面の右端に列を追加して描く
  - バリエーション画面は別画面で作る
    - ドロップダウン展開状態やインライン編集モードなど、元の画面をコピーして別画面として作る（元画面を汚さない）

## 作業の順番

1. 要件定義で作ったドキュメントを読ませる
2. ユーザーフロー設計
   - デザイン前に作成する。デザイン後に過不足に気づいて修正するので、作り込みすぎないこと
   - 作りづらければ、先にラフデザインを作らせてからそれを元に作る
3. デザインの方向性を一緒に決める
   - 要件を満たす最適なデザインを作ってほしいと伝える（ターゲットとユースケースを伝えてそれに最適なUI/UXを提案してもらう形）
   - レスポンシブ対応の必要性を伝える
   - スタイルガイドをつくる
     - 色、フォント、スペーシング、角丸、シャドウなどの基準を決める
     - 色を決めるときはコントラストに注意する（WCAGの基準を参考にする）
     - 作成方法
       - Skillsのui-ux-pro-maxの--design-system
         - 要件書や設計書が充実していれば、がドキュメントなどから自動で作ってくれるので便利そう。
         - ただし、ドキュメントがないと勝手に想像で作るので、あまり意味ない。項目の参考程度。
         - むしろ、ui-ux-pro-maxは参考サイトを提示して「こんな感じのデザインにしたい」と伝えて、スタイルガイドを作ってもらうという使い方が良さそう。
       - Claude Codeなどと作る。
4. デザイン開始
   1. 基準をつくる（コンポーネントセクションの作成）
      - スタイルガイドを元に変数を定義。コンポーネントセクションに可視化しておくと見やすい。
      - コンポーネントを作成する
        - 無秩序にoverrideして対応されないように、色やサイズなどのvariantを定義して、基本的にはoverrideさせずに対応する。
   2. デザインさせる（基本的に共通部品はコンポーネントを作らせる）
   3. フィードバックして修正させる（必要に応じて、ユーザーフロー設計を修正）
   4. 2,3を繰り返す
   5. （作成中にスタイルガイドで定義した値を変更する場合、二重管理で面倒なのでスタイルガイドのドキュメンは消しても良いかも）
5. ui-ux-pro-maxでレビューさせる
   1. 修正させて、レビューさせて、を繰り返す

## トラブル

### コンポーネントのref（インスタンス）作成に制約がある

**事象**: MCP API（batch_design）でコンポーネントのrefを作成しようとすると、refにならずframeに展開（コピー）されるケースがある。

**ref化できたもの**:

- Button/Primary（子: icon_font + text。フラットな構造）
- TabBar/Home（子: TabBarItem/Active・Inactiveへのref。子がref構成）

**ref化できなかったもの**:

- Sidebar/Home（子: appHeader, navHome等のframe。各frameの中にicon + textが入れ子）

**試したこと**:

1. I() で `{type: "ref", ref: "componentId"}` → frameに展開される
2. R() で既存ノードをrefに置換 → frameに展開される
3. C() でreusableノードをコピー → frameに展開される（ドキュメントには「refが作られる」と記載）
4. Sidebarの子frameをSidebarItem/Active等のコンポーネントに切り出してref構成にし、Sidebar自体をref化 → 依然としてframeに展開。さらに、作成したSidebarItemコンポーネント自体が消失し、Sidebarの子も元の状態にロールバックされた

**原因の推測**:

- `layout: "vertical"` を持つコンポーネント、または入れ子のframeを持つコンポーネントはref化できない可能性がある（ref化できたButton/TabBarにはlayoutプロパティがなく、子も単純な構造）
- pencil.devが内部でコンポーネントの整合性を保っており、参照先が不正になるとロールバックする動きがある

**対処法**:

- ref化できないコンポーネントは各画面にコピー（frame）として配置し、変更時は全画面を個別に更新する

### batch_getでトークン上限を超える

**事象**: デザインファイルが大きくなると、`batch_get` の結果が数十MBになりトークン上限を超えて読めなくなる。

**やってはいけないこと**:

- パターン検索で広範囲を取得する（`patterns: ["Dialog"]` のような曖昧な検索はドキュメント全体を走査する）
- `readDepth` を大きくしすぎる（3を超えるとデータ量が爆発する）

**対処法**:

1. `get_editor_state` で全体構造を把握する（トップレベルノード一覧・コンポーネント一覧が返る）
2. `nodeIds` で特定ノードを指定して読む（パターン検索よりも確実）
3. `readDepth` を制御する（デフォルト1。2〜3で十分なことが多い）

```
# NG: パターンで全体検索 → 数十MBでトークン上限超過
batch_get(patterns: ["<探したいフレーム名>"])

# OK: まずget_editor_stateでノード一覧を取得し、目的のノードIDを特定
get_editor_state(include_schema: false)

# OK: 特定のノードIDをreadDepth指定で読む
batch_get(nodeIds: ["<特定したノードID>"], readDepth: 3)
```

### C() で画面コピー後のパス解決に制約がある

**事象**: `C()` で画面をコピーした後、`scr+"/taskList/task2"` のような名前ベースの多階層パスで子ノードを参照しようとすると `No such node` エラーになった（1階層のパスが通るかは未検証）。

**今回の回避策**:

- コピーを諦め、`I()` で1から画面を構築した
- 構築は複数の `batch_design` 呼び出しに分割（1回あたり最大25操作）
- 前のバッチで作ったノードのIDはレスポンスから取得し、次のバッチで文字列として直接使った
